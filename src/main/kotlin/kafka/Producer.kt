/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package kafka

import org.apache.kafka.clients.producer.*
import org.apache.kafka.common.serialization.StringSerializer
import java.time.LocalDateTime
import java.util.*
import java.util.concurrent.CompletableFuture

class Producer(
    config: Config
) {
    private val producer: KafkaProducer<String, String>
    private val topic: String

    data class Config(
        val topic: String,
        val driverProperties: Map<String, Any>
    )

    init {
        val properties = Properties().apply {
            put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer::class.java)
            put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer::class.java)
            config.driverProperties.entries.forEach {
                put(it.key, it.value)
            }
        }
        producer = KafkaProducer(properties)
        topic = config.topic
    }

    fun send(key: String, value: String): RecordMetadata {
        val producerRecord = ProducerRecord<String, String>(topic, key, value)
        val completableCallback = CompletableCallback()
        producer.send(producerRecord, completableCallback)
        return completableCallback.completableFuture.get()
    }

    inner class CompletableCallback : Callback {
        val completableFuture = CompletableFuture<RecordMetadata>()

        override fun onCompletion(metadata: RecordMetadata?, exception: Exception?) {
            if (exception == null) {
                completableFuture.complete(metadata)
            } else {
                completableFuture.completeExceptionally(exception)
            }
        }
    }

}

fun main(args: Array<String>) {
    val kafkaProducer = Producer(Producer.Config(
        topic = "demo-topic",
        driverProperties = mapOf(
            "bootstrap.servers" to "localhost:11092"
        )
    ))
    (1..10).forEach {
        val msg = "test message $it ${LocalDateTime.now()}"
        kafkaProducer.send(it.toString(), msg)
    }

}
